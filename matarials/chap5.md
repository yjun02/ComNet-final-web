### **네트워크 계층 제어 평면(Control Plane)의 개요**

네트워크 계층의 핵심 기능은 포워딩과 라우팅으로 나뉩니다. 데이터 평면이 패킷을 입력 포트에서 출력 포트로 옮기는 로컬한 작업(Forwarding)을 담당한다면, 제어 평면은 패킷이 출발지부터 목적지까지 가는 전체 경로(Routing)를 결정합니다.

제어 평면을 구조화하는 방식에는 두 가지 접근법이 있습니다:

- **Per-router Control (전통적 방식):** 각 라우터마다 라우팅 알고리즘 구성 요소가 존재하며, 라우터들끼리 제어 메시지를 주고받으며 로컬 포워딩 테이블을 직접 계산합니다.
- **Logically Centralized Control (SDN 방식):** 각 라우터는 단순히 명령을 수행하는 장치 역할만 하며, 중앙의 원격 컨트롤러가 모든 라우터의 포워딩/플로우 테이블을 계산하여 배포합니다.

---

### **라우팅 알고리즘 (Routing Algorithms)**

라우팅 알고리즘의 목표는 송신지에서 수신지까지 **최소 비용(Least Cost)** 경로를 찾는 것입니다. 네트워크는 그래프 $G = (N, E)$로 모델링되며, $N$은 라우터(노드)의 집합, $E$는 라우터 간 연결된 링크의 집합입니다. 각 링크에는 거리, 대역폭, 혼잡도 등을 반영한 비용(Cost)이 할당됩니다.

알고리즘은 정보의 가용 범위에 따라 두 가지로 분류됩니다:

- **Link State (LS) 알고리즘:** 모든 라우터가 네트워크 전체의 토폴로지와 모든 링크 비용 정보를 알고 있는 상태에서 계산합니다.
- **Distance Vector (DV) 알고리즘:** 이웃 노드와만 정보를 교환하며 반복적으로 계산을 수행합니다.

---

### **Link State (LS): Dijkstra 알고리즘**

모든 노드가 네트워크 지도를 완벽하게 알고 있다는 가정하에 동작하는 알고리즘으로, **Dijkstra(다익스트라)** 알고리즘이 대표적입니다.

- **동작 원리:** 한 노드(출발지)에서 시작하여, 경로 비용이 가장 적은 노드들을 순차적으로 '확정된 노드 집합($N'$)'에 추가하면서 최단 경로를 구합니다.
- **알고리즘 단계:**
    1. 출발 노드의 비용을 0으로, 나머지 모든 노드의 비용을 무한대로 초기화합니다.
    2. 아직 확정되지 않은 노드 중 현재까지 계산된 비용이 가장 적은 노드를 선택합니다.
    3. 선택된 노드를 거쳐서 이웃 노드로 가는 새로운 경로 비용을 계산하여, 기존 비용보다 저렴하면 업데이트합니다.
    4. 모든 노드가 확정될 때까지 이 과정을 반복합니다.
- **특징:** 계산 복잡도는 $O(n^2)$이며, 모든 링크 상태를 방송(Broadcast)해야 합니다. 트래픽 양에 따라 링크 비용이 변할 경우 경로가 계속 바뀌는 **진동(Oscillation)** 문제가 발생할 수 있습니다.

---

### **Distance Vector (DV): Bellman-Ford 알고리즘**

DV 알고리즘은 전체 지도 대신 이웃이 보내준 거리 정보에 의존하는 분산형 알고리즘입니다.

- **Bellman-Ford 방정식:** $d_x(y) = \min_v \{ c(x,v) + d_v(y) \}$. 즉, $x$에서 $y$까지의 최단 거리는 $x$의 이웃 $v$까지의 비용과 $v$가 알려준 $y$까지의 최단 거리 합 중 최소값입니다.
- **동작 방식:**
    1. 각 노드는 자신의 이웃까지의 비용 정보(Distance Vector)를 주기적으로 혹은 변화가 있을 때 이웃에게 보냅니다.
    2. 이웃으로부터 정보를 받으면 자신의 테이블을 업데이트하고, 변화가 생기면 다시 이웃에게 알립니다.
- **특징:** 반복적이고 분산적입니다. 노드들이 서로의 정보에만 의존하기 때문에 정보가 수렴될 때까지 시간이 걸립니다.

---

### **DV 알고리즘의 문제점: Count-to-Infinity**

DV 알고리즘은 링크 비용이 감소하는 "좋은 소식"은 빠르게 전파되지만, 비용이 증가하는 **"나쁜 소식"은 매우 느리게 전파**되는 문제가 있습니다.

- **현상:** 링크 비용이 끊기거나 급증하면 노드들끼리 서로 "내 옆 노드를 통하면 더 싸게 갈 수 있다"는 잘못된 정보를 주고받으며 루프에 빠지고, 비용 값이 무한대까지 계속 증가합니다.
- **해결책 (Poisoned Reverse):** 만약 노드 $Z$가 $X$로 가기 위해 $Y$를 거치고 있다면, $Z$는 $Y$에게 "$X$까지 가는 내 비용은 무한대($\infty$)"라고 거짓 정보를 주어 $Y$가 다시 $Z$를 통해 $X$로 가려는 루프를 방지합니다.

---

### **LS vs DV 알고리즘 비교**

두 알고리즘은 성능과 견고성 측면에서 뚜렷한 차이를 보입니다.

- **메시지 복잡도:** LS는 전체 네트워크에 정보를 방송해야 하므로 메시지가 많지만, DV는 이웃끼리만 교환합니다.
- **수렴 속도:** LS는 $O(n^2)$의 연산으로 빠르게 수렴하지만, DV는 수렴 속도가 느리고 루프가 발생할 수 있습니다.
- **견고성(Robustness):** LS는 라우터가 고장 나도 자신의 테이블만 영향을 받지만, DV는 잘못된 경로 비용 정보가 전체 네트워크로 전파될 위험이 큽니다.

### **네트워크의 계층적 구조: Autonomous Systems (AS)**

실제 인터넷은 수십억 개의 노드가 연결되어 있어 모든 경로를 하나의 라우팅 테이블에 담는 것이 불가능합니다. 이를 해결하기 위해 인터넷은 라우터들을 **AS(Autonomous Systems)**라는 단위로 그룹화하여 관리합니다.

- **Intra-AS Routing (AS 내부 라우팅):** 동일한 AS 내에 있는 라우터들끼리 수행하는 라우팅입니다. 모든 라우터는 동일한 프로토콜을 사용해야 합니다.
- **Inter-AS Routing (AS 간 라우팅):** 서로 다른 AS들을 연결하는 라우팅입니다. AS 경계에 위치한 **Gateway Router**가 이 역할을 수행합니다.

---

### **Intra-AS Routing: OSPF (Open Shortest Path First)**

OSPF는 현대 인터넷의 AS 내부에서 가장 널리 쓰이는 프로토콜입니다.

- **기반 알고리즘:** 앞서 배운 **Link State (LS)** 알고리즘인 **Dijkstra**를 사용합니다.
- **동작 방식:**
    - 라우터는 AS 내의 모든 라우터에게 링크 상태 정보를 방송(Link State Advertisement)합니다.
    - 이를 통해 모든 라우터는 전체 네트워크의 완벽한 지도를 갖게 됩니다.
- **계층적 OSPF (Hierarchical OSPF):** AS가 너무 커지면 이를 **Area**로 나누어 관리합니다. 각 Area 내에서만 상세 지도를 공유하고, Area 간에는 요약된 정보만 전달하여 효율성을 높입니다.

---

### **Inter-AS Routing: BGP (Border Gateway Protocol)**

BGP는 서로 다른 AS들을 하나로 묶어주는 **"인터넷의 접착제"**와 같은 프로토콜입니다.

- **특징:** 단순히 최단 거리를 찾는 것이 아니라, **Policy-based Routing(정책 기반 라우팅)**을 수행합니다. (예: "우리 회사는 경쟁사 AS를 거치는 경로를 쓰지 않겠다")
- **BGP 세션:**
    - **eBGP:** 인접한 서로 다른 AS 간에 경로 정보를 교환합니다.
    - **iBGP:** AS 내부의 라우터들에게 외부에서 얻은 경로 정보를 전파합니다.
- **Path Attributes:** BGP는 `AS-PATH`(지나온 AS 목록), `NEXT-HOP`(다음 관문 라우터) 등의 속성을 사용하여 루프를 방지하고 최적 경로를 결정합니다.
- **Hot Potato Routing:** 자신의 AS 밖으로 패킷을 최대한 빨리(가장 가까운 게이트웨이로) 던져버리는 방식을 선호하기도 합니다.

---

### **SDN Control Plane (Software Defined Networking)**

전통적인 라우팅이 각 라우터가 개별적으로 결정하는 방식이라면, SDN은 **논리적으로 중앙 집중화된 컨트롤러**가 전체 네트워크를 관리하는 혁신적인 방식입니다.

- **구조:**
    - **Data Plane:** 단순한 스위치들이 컨트롤러가 하달한 **Flow Table**에 따라 패킷을 전달(Match+Action)만 합니다.
    - **Control Plane:** 중앙 컨트롤러가 네트워크 전체 상태를 파악하고 각 스위치에 명령을 내립니다.
- **장점:** 네트워크 관리가 유연해지고, 소프트웨어적으로 다양한 정책(트래픽 엔지니어링 등)을 쉽게 적용할 수 있습니다.
- **OpenFlow:** 컨트롤러와 스위치 사이의 대화를 위한 표준 프로토콜입니다.

---

### **ICMP (Internet Control Message Protocol)**

네트워크 상태를 확인하고 에러를 보고하기 위한 프로토콜입니다. IP 데이터그램의 페이로드에 담겨 전송됩니다.

- **주요 기능:**
    - **Error Reporting:** "목적지에 도달할 수 없음(Destination Unreachable)", "시간 초과(TTL expired)" 등을 보고합니다.
    - **Echo Request/Reply:** 우리가 흔히 쓰는 `ping` 명령어가 이 기능을 사용합니다.
- **Traceroute:** TTL 값을 1부터 하나씩 늘려가며 ICMP "Time Exceeded" 메시지를 유발해 목적지까지의 경로에 있는 모든 라우터의 주소를 알아내는 기술입니다.

---

### **네트워크 관리 및 구성 (SNMP/NETCONF)**

네트워크 장비들을 모니터링하고 설정하기 위한 도구들입니다.

- **SNMP (Simple Network Management Protocol):** 관리 서버가 장비 내의 **MIB(Management Information Base)** 정보를 조회하거나 수정합니다.
- **NETCONF/YANG:** 더 현대적이고 정교한 설정을 위해 사용됩니다. **YANG**이라는 데이터 모델링 언어를 사용하여 구성 정보를 정의하고 **NETCONF** 프로토콜로 이를 전송합니다.

---