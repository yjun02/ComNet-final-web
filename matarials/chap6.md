## 1. 링크 계층 서론 (Introduction)

### 1.1 용어 정리 (Terminology)

- **Nodes (노드):** 호스트와 라우터.
- **Links (링크):** 통신 경로를 따라 인접한 노드들을 연결하는 통신 채널 (유선, 무선, LANs).
- **Frame (프레임):** 2계층 패킷. 네트워크 계층의 데이터그램을 캡슐화함.
- **핵심 책임:** 데이터그램을 한 노드에서 링크를 통해 **물리적으로 인접한(Adjacent)** 다음 노드로 전송하는 것.

### 1.2 링크 계층의 문맥 (Context)

- 데이터그램은 경로에 따라 **서로 다른 링크 프로토콜**에 의해 전달될 수 있습니다. (예: 첫 번째 링크는 WiFi, 다음 링크는 Ethernet)
- **교통수단 비유:**
    - 여행객 = 데이터그램
    - 교통수단 (리무진, 비행기, 기차) = 링크 계층 프로토콜
    - 여행 구간 = 통신 링크
    - 여행사 (Travel Agent) = 라우팅 알고리즘

### 1.3 제공 서비스 (Services)

- **Framing & Link Access:** 데이터그램을 프레임으로 캡슐화하고 헤더/트레일러 추가. 공유 매체일 경우 채널 접근 제어 수행. 프레임 헤더의 **MAC 주소**로 송/수신지 식별 (IP 주소와 다름!).
- **Reliable Delivery:** 인접 노드 간 신뢰적 전송. 오류율이 높은 무선 링크에서 주로 사용.
- **Flow Control:** 인접한 송/수신 노드 간의 속도 조절.
- **Error Detection:** 신호 감쇠나 노이즈로 인한 오류 감지. 수신 측에서 오류 발견 시 재전송 요청 또는 프레임 폐기.
- **Error Correction:** 재전송 없이 비트 오류를 스스로 식별하고 수정.
- **Half-duplex & Full-duplex:** 반이중(양방향 가능하나 동시는 불가) 및 전이중 전송 지원.

---

## 2. 구현 및 다중 접속 (Implementation & Multiple Access)

### 2.1 링크 계층은 어디에 구현되는가?

- 모든 호스트의 **NIC (Network Interface Card)** 또는 단일 칩에 구현됨.
- 호스트의 시스템 버스(PCI 등)에 연결되며 하드웨어, 소프트웨어, 펌웨어의 조합으로 구성됨.
- **송신 측:** 데이터그램 캡슐화, 오류 검사 비트 추가, 신뢰적 전송 및 흐름 제어 수행.
- **수신 측:** 오류 확인, 데이터그램 추출 후 상위 계층으로 전달.

### 2.2 다중 접속 링크와 프로토콜 (Multiple Access)

- **Point-to-Point:** 이더넷 스위치와 호스트 사이의 연결, 다이얼업 access를 위한 PPP 등.
- **Broadcast (공유 매체):** 유선 이더넷, 무선 LAN(802.11), 위성, 4G/5G 등.
- **Multiple Access Protocol:**
    - 단일 공유 브로드캐스트 채널에서 두 노드 이상이 동시에 전송하면 **충돌(Collision)** 발생.
    - 노드들이 채널을 공유하는 시점을 결정하는 **분산 알고리즘**.
    - 조율을 위한 별도의 채널(Out-of-band) 없이 해당 채널 자체를 사용해야 함.

---

## 3. LAN 주소 체계와 ARP (Addressing & ARP)

### 3.1 MAC 주소 (MAC Addresses)

- **IP 주소 (32비트):** 계층 3(네트워크 계층) 포워딩을 위한 주소.
- **MAC 주소 (48비트):** 로컬하게 인접한 인터페이스로 프레임을 전달하기 위한 **물리 주소**.
    - 보통 NIC의 ROM에 고정되어 있으며 16진수 표기법(예: `1A-2F-BB-76-09-AD`)을 사용함.
    - **비유:** MAC 주소는 주민등록번호(불변), IP 주소는 우편 주소(위치에 따라 변함).
    - MAC 주소는 평면(Flat) 구조라 어디로 옮겨도 유지되지만(Portability), IP 주소는 서브넷에 종속적이라 이동 시 변경됨.

### 3.2 ARP (Address Resolution Protocol)

- **질문:** IP 주소를 알 때, 해당 인터페이스의 MAC 주소를 어떻게 알아낼까?
- **ARP Table:** LAN의 각 노드(호스트, 라우터)는 IP/MAC 매핑 정보를 담은 테이블을 가짐. (TTL 포함, 보통 20분 후 삭제)
- **작동 과정:**
    1. A가 B의 MAC 주소를 모를 때, 목적지 MAC 주소를 **FF-FF-FF-FF-FF-FF (브로드캐스트)**로 설정하여 ARP 쿼리 전송.
    2. LAN의 모든 노드가 수신하지만, 매칭되는 IP를 가진 B만 A에게 **유니캐스트**로 응답.
    3. A는 응답을 받아 자신의 ARP 테이블에 저장.

---

## 4. 다른 서브넷으로의 라우팅 (Routing to another subnet)

호스트 A(서브넷 1)가 호스트 B(서브넷 2)로 데이터그램을 보내는 과정입니다. (핵심: MAC 주소는 홉마다 바뀜!)

1. **A에서 출발:**
    - IP 헤더: Source=A_IP, Dest=B_IP (변하지 않음).
    - 프레임 헤더: Source=A_MAC, **Dest=Router(R)_MAC** (첫 홉 라우터로 전달하기 위함).
    - 프레임이 라우터 R의 인터페이스로 전달됨.
2. **라우터 R에서의 처리:**
    - 프레임을 수신하여 데이터그램을 추출한 뒤 IP 계층으로 올림.
    - IP 계층에서 목적지(B_IP)를 보고 나가는 인터페이스를 결정.
3. **R에서 B로 전달:**
    - IP 헤더: Source=A_IP, Dest=B_IP (유지).
    - 새 프레임 생성: Source=R_MAC(나가는 쪽 인터페이스), **Dest=B_MAC**.
    - 최종적으로 호스트 B가 프레임을 수신하여 데이터그램을 처리함.

---

## 1. Ethernet: 유선 LAN의 절대 강자 (p.27 ~ p.28)

이더넷은 현재 가장 널리 쓰이는 유선 LAN 기술입니다.

- **성공 비결:** 초기 LAN 기술 중 가장 먼저 보급되었고, 구조가 단순하며 가격이 저렴합니다. 또한, 기술 발전에 맞춰 속도를 10 Mbps에서 최근 400 Gbps까지 비약적으로 끌어올리며 생존해왔습니다.
- **물리적 토폴로지(Topology)의 변화:ㄹ**
    - **Bus(버스형):** 90년대 중반까지 유행했습니다. 모든 노드가 하나의 동축 케이블을 공유하므로, 모든 노드가 동일한 **Collision Domain(충돌 도메인)**에 속해 있었습니다.
    - **Switched(스위치형):** 현재의 방식입니다. 중앙에 **Layer 2 Switch**가 있고 각 노드가 전용 링크로 연결됩니다. 노드 간에 직접적인 충돌이 발생하지 않습니다.

---

## 2. Ethernet 프레임 구조 (p.29 ~ p.30)

이더넷은 네트워크 계층의 데이터그램을 다음과 같은 프레임으로 캡슐화합니다.

| **필드** | **크기** | **역할** |
| --- | --- | --- |
| **Preamble** | 8 bytes | 수신자와 송신자의 클록 속도를 동기화합니다. (10101010이 7번 반복된 후 10101011로 끝남) |
| **Dest. Addr** | 6 bytes | 수신지 **MAC 주소**. 자신의 MAC이나 브로드캐스트 주소와 맞지 않으면 폐기합니다. |
| **Source Addr** | 6 bytes | 송신지 **MAC 주소**. |
| **Type** | 2 bytes | 상위 계층 프로토콜(주로 IP)의 종류를 나타내며, 수신 측에서 디멀티플렉싱에 사용합니다. |
| **Data (Payload)** | 46~1500 bytes | 실제 데이터(IP 데이터그램 등)가 들어가는 부분입니다. |
| **CRC** | 4 bytes | 오류 검출을 위한 순환 중복 검사 값입니다. 오류 발견 시 프레임을 버립니다. |

---

## 3. Ethernet의 특징 및 표준 (p.31 ~ p.32)

- **Connectionless(비연결성):** 송수신 NIC 간에 핸드쉐이킹 과정이 없습니다.
- **Unreliable(비신뢰성):** 수신 NIC는 송신 NIC에게 ACK나 NAK를 보내지 않습니다.
    - 오류로 프레임이 버려지면, 데이터 복구는 오직 상위 계층(TCP 등)의 책임입니다.
- **MAC 프로토콜:** 충돌 감지 및 재전송을 위해 **CSMA/CD (Unslotted)**와 **Binary Backoff** 알고리즘을 사용합니다.
- **802.3 표준:** 이더넷은 속도(100BASE-TX, 1Gbps 등)와 매체(광섬유, 구리선)에 따라 다양한 표준이 있지만, **MAC 프로토콜과 프레임 형식은 공통**으로 사용합니다.

---

## 4. Ethernet Switch: 스마트한 연결 장치 (p.34 ~ p.36)

스위치는 링크 계층(Layer 2) 장비로, 들어오는 프레임의 MAC 주소를 보고 특정 링크로만 전달하는 역할을 합니다.

- **Transparent(투명성):** 호스트들은 중간에 스위치가 있는지 알지 못합니다.
- **Plug-and-play:** 별도의 설정 없이 선만 꽂으면 작동하는 자가 학습(Self-learning) 장치입니다.1
- **동시 전송 가능:** 스위치는 패킷을 버퍼링하고 각 링크를 독립적인 충돌 도메인으로 격리합니다.
    - 예를 들어, **A가 A'에게** 보내는 동시에 **B가 B'에게** 데이터를 보내도 충돌이 발생하지 않습니다. (Full Duplex 지원)
    - 단, **A와 C가 동시에 A'에게** 보내려고 하면 출력 포트에서 경합이 발생하므로 동시 처리가 불가능합니다.

---

## 5. 스위치의 핵심: 자가 학습(Self-learning) (p.37 ~ p.40)

스위치는 **Switch Table**을 사용하여 어떤 MAC 주소가 어느 인터페이스(포트)에 연결되어 있는지 기억합니다.

### 5.1 스위치 테이블의 구성

`(호스트 MAC 주소, 인터페이스 번호, TTL(유효 시간))`

### 5.2 프레임 처리 알고리즘 (Filtering/Forwarding)

프레임이 도착하면 스위치는 다음 과정을 거칩니다:

1. **기록(Learning):** 들어온 프레임의 **송신지(Source) MAC**과 인터페이스 번호를 테이블에 저장합니다.
2. **조회(Lookup):** 프레임의 **수신지(Destination) MAC**을 테이블에서 찾습니다.
3. **결과에 따른 동작:**
    - **Entry 발견 + 도착한 포트와 같은 포트:** 프레임을 버립니다 (**Filter**).
    - **Entry 발견 + 다른 포트:** 해당 포트로만 보냅니다 (**Forward**).
    - **Entry 없음:** 들어온 포트를 제외한 모든 포트로 뿌립니다 (**Flood**).

---

## 6. 스위치 vs. 라우터 비교 (p.44)

시험에 자주 나오는 핵심 비교 포인트입니다.

| **구분** | **Switch (스위치)** | **Router (라우터)** |
| --- | --- | --- |
| **계층** | **Link Layer (Layer 2)** | **Network Layer (Layer 3)** |
| **주요 헤더** | MAC 주소 확인 | IP 주소 확인 |
| **테이블 구축** | **Self-learning, Flooding** (자동) | **Routing Algorithms** (RIP, OSPF 등) |
| **작동 방식** | 프레임 교환 | 데이터그램 경로 결정 |

---

### [심화] Multi-switch 예시 (p.42)

**상황: C가 I에게 프레임을 보내고, I가 다시 C에게 응답할 때**

1. **C → I 전송 시:**
    - S1은 C의 위치를 학습하고, I의 위치를 모르므로 모든 포트로 Flood합니다.
    - S4, S2, S3 순차적으로 C의 위치를 학습하며 I를 찾기 위해 Flood를 이어갑니다.
2. **I → C 응답 시:**
    - I가 응답을 보내는 순간 S3는 I의 위치를 학습합니다.
    - 이때 S3는 이미 앞선 과정에서 **"C는 S4 방향에 있다"**는 것을 학습했으므로, Flood 하지 않고 **S4로만 유니캐스트(Unicast)**로 전달합니다.
    - 이후 S4, S1도 같은 원리로 C에게 정확히 전달합니다.